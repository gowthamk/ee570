#lang racket
;; MIN-MAX algorithm that I have adopted seems to be buggy.

(define (panic str)
  (raise str))
(define infinity +Inf.0)
(define ~infinity -Inf.0)

(define (tabulate n f)
  (if (<= n 0) '() (append (tabulate (- n 1) f) (list (f n)))))

(define (initial-board n)
  (tabulate n (lambda (row) (tabulate n 
    (lambda (col) 0)))))

(define (mymap l f)
  (if (null? l) '()
    (cons (f (first l)) (mymap (rest l) f))))

(define (foldl l acc f)
  (if (null? l) acc
    (foldl (rest l) (f (first l) acc) f)))

;(define (foldfold l f b)
;  (foldl l b (lambda (l1 acc) (foldl l1 acc f))))

(define (map-at-index n l f)
  (define (loop l i f)
    (cond ((null? l) (panic "Invalid index for map-at-index"))
          ((= i n) (cons (f (first l)) (rest l)))
          ((< i n) (cons (first l) (loop (rest l) (+ i 1) f)))
          (else l)))
  (loop l 1 f))

(define (map-brd-at-pos pos brd f)
  (let* ((row (first pos))
         (col (second pos)))
    (map-at-index row brd (lambda (l) 
         (map-at-index col l f)))))

(define (foldfold brd f b)
  (second (foldl brd (list 1 b) (lambda (l acc)
    (let* ((row (first acc))
           (acc (second acc))
           (newacc (foldl l (list (list row 1) acc)
             (lambda (x arg) 
               (let* ((pos (first arg))
                      (row (first pos))
                      (col (second pos))
                      (acc (second arg))
                      (posx (list pos x))
                      (colacc (f posx acc)))
                 (list (list row (+ col 1)) colacc))))))
      (list (+ row 1) (second newacc)))))))

(define (current-player brd)
  (let* ((nx (foldfold brd 
                (lambda (posx acc) 
                  (if (= (second posx) 1) (+ 1 acc) acc)) 0))
         (n0 (foldfold brd 
                (lambda (posx acc) 
                  (if (= (second posx) -1) (+ 1 acc) acc)) 0)))
    (cond
      ((> nx n0) -1)
      ((>= n0 nx) 1))))

(define (moves brd)
  (foldfold brd (lambda (posx acc)
    (if (= (second posx) 0) (append acc (list (first posx)))
        acc)) '()))

(define (poseq? pos1 pos2)
  (and (= (first pos1) (first pos2))
       (= (second pos1) (second pos2))))

(define (make-move m brd) 
  (let* ((cp (current-player brd))
         (mapfn (lambda (x) 
            (if (= x 0) cp
                (panic "Invalid Move")))))
    (map-brd-at-pos m brd mapfn)))

(define (make-moves ms brd) 
  (foldl ms brd make-move))

(define (brd-dimension brd) 
  (length brd))

;; checks if P1 or P2 is winner along
;; all positions defined by pospred.
;; If pospred is false, then both P1 and
;; P2 are winners.
(define (check-brd pospred brd)
  (foldfold brd (lambda (posx res) 
    (if (pospred (first posx))
        (let* ((x (second posx))
               (resp1 (first res))
               (resp2 (second res))
               (p1 (and resp1 (= x 1)))
               (p2 (and resp2 (= x -1))))
          (list p1 p2))
        res)) (list #t #t)))
;; checks board n times, each time with pospred(n)
(define (check-brd-till n pospred brd)
  (if (= n 0) (list #f #f)
      (let* ((res1 (check-brd-till (- n 1) pospred brd))
             (res (if (or (first res1) (second res1)) res1
                      (check-brd (pospred n) brd))))
        res)))
(define (check-rows-till n brd)
  (check-brd-till n (lambda (n) (lambda (pos) (= (first pos) n))) brd))
(define (check-cols-till n brd)
  (check-brd-till n (lambda (n) (lambda (pos) (= (first pos) n))) brd))
(define (check-diag1 brd) 
  (check-brd (lambda (pos) (= (first pos) (second pos))) brd))
(define (check-diag2 brd)
  (let* ((n (brd-dimension brd)))
    (check-brd (lambda (pos) (= (+ n 1) (+ (first pos) (second pos)))) brd)))

;; count fns
(define (check-brd2 pospred brd)
  (foldfold brd (lambda (posx res) 
    (if (pospred (first posx))
        (let* ((x (second posx))
               (resp1 (first res))
               (resp2 (second res))
               (p1 (and resp1 (or (= x 1) (= x 0))))
               (p2 (and resp2 (or (= x -1) (= x 0)))))
          (list p1 p2))
        res)) (list #t #t)))
(define (count-brd-till n pospred brd)
  (if (= n 0) (list 0 0)
      (let* ((resacc (count-brd-till (- n 1) pospred brd))
             (res (check-brd2 (pospred n) brd)))
        (list (if (first res) (+ (first resacc) 1) (first resacc))
              (if (second res) (+ (second resacc) 1) (second resacc))))))
(define (count-rows-till n brd)
  (count-brd-till n (lambda (n) (lambda (pos) (= (first pos) n))) brd))
(define (count-cols-till n brd)
  (count-brd-till n (lambda (n) (lambda (pos) (= (first pos) n))) brd))
(define (count-diag1 brd) 
  (let* ((res (check-brd2 (lambda (pos) 
            (= (first pos) (second pos))) brd)))
    (mymap res (lambda (flag) (if flag 1 0)))))
(define (count-diag2 brd) 
  (let* ((n (brd-dimension brd))
         (res (check-brd2 (lambda (pos) 
            (= (+ n 1) (+ (first pos) (second pos)))) brd)))
    (mymap res (lambda (flag) (if flag 1 0)))))

;; Static eval fn
(define (static-eval brd)
  (let* ((n (brd-dimension brd))
         (cp (current-player brd))
         (c1 (count-rows-till n brd))
         (c2 (count-cols-till n brd))
         (c3 (count-diag1 brd))
         (c4 (count-diag2 brd))
         (c1s (list (first c1) (first c2) (first c3) (first c4)))
         (c2s (list (second c1) (second c2) (second c3) (second c4)))
         (c1 (foldl c1s 0 (lambda (x acc) (+ x acc))))
         (c2 (foldl c2s 0 (lambda (x acc) (+ x acc))))
         (val (/ (- c1 c2) (* n n))))
    (cond ((= cp 1) val)
          ((= cp -1) val)
          (else 0))))

(define (win brd) 
  (let* ((n (brd-dimension brd))
         (res1 (check-rows-till n brd))
         (res2 (if (or (first res1) (second res1)) res1 
                   (check-cols-till n brd)))
         (res3 (if (or (first res2) (second res2)) res2 
                   (check-diag1 brd)))
         (res (if (or (first res3) (second res3)) res3 
                   (check-diag2 brd))))
    (if (first res) 1 (if (second res) -1 0))))

(define (terminal-test brd) 
  (if (or (= 1 (win brd)) (= -1 (win brd))) #t #f))

(define (maximize k brd a b)
  (define (loop moves maxacc a b) 
    (if (null? moves) maxacc
        (let* ((curmove (first moves))
               (maxsofar (first maxacc))
               (depthsofar (second maxacc))
               (optmovessofar (third maxacc))
               (curvm (minimize (- k 1) 
                    (make-move curmove brd) a b))
               (curval (first curvm))
               (curdepth (+ 1 (second curvm)))
               (maxvm (cond ((> maxsofar curval) maxacc)
                            ((and (= maxsofar curval) (< depthsofar curdepth)) 
                               maxacc)
                            ((and (= maxsofar curval) (= depthsofar curdepth)) 
                               (list maxsofar depthsofar
                                 (cons curmove optmovessofar)))
                            (else (list curval curdepth (list curmove)))))
               (maxval (first maxvm)))
          (if (>= maxval b) maxvm (loop (rest moves) 
                 maxvm maxval b)))))
  (let* ((n (brd-dimension brd)))
    (cond ((terminal-test brd) (list (win brd) 0 '()))
        ((= k 0) (list (static-eval brd) (* n n) '() ))
        (else (loop (moves brd) (list -1 infinity '()) a b)))))

(define (minimize k brd a b)
  (define (loop moves minacc a b) 
    (if (null? moves) minacc
        (let* ((curmove (first moves))
               (minsofar (first minacc))
               (depthsofar (second minacc))
               (optmovessofar (third minacc))
               (curvm (maximize (- k 1) 
                    (make-move curmove brd) a b))
               (curval (first curvm))
               (curdepth (+ 1 (second curvm)))
               (minvm (cond ((< minsofar curval) minacc)
                            ((and (= minsofar curval) (< depthsofar curdepth)) 
                               minacc)
                            ((and (= minsofar curval) (= depthsofar curdepth)) 
                               (list minsofar depthsofar
                                 (cons curmove optmovessofar)))
                            (else (list curval curdepth (list curmove)))))
               (minval (first minvm)))
          (if (<= minval a) minvm (loop (rest moves) 
                 minvm a minval)))))
    (let* ((n (brd-dimension brd)))
    (cond ((terminal-test brd) (list (win brd) 0 '()))
        ((= k 0) (list (static-eval brd) (* n n) '() ))
        (else (loop (moves brd) (list 1 infinity '()) a b)))))

(define (optimal-moves~ k brd)
  (let* ((k (if (= k 0) infinity k))
        (maxvdm (maximize k brd ~infinity infinity)))
    (third maxvdm)))
